@model Web.Models.OrderViewModel
@using Models.Data
@using Models.Entities
@using Models.Entities.Enums
@using System.Text.Json

@{
	ViewData["Title"] = "Bestelling plaatsen";
	var context = ViewBag.Context as LocalDbContext;
	var coffees = context.Coffees.ToArray(); // lijst met bonen (Arabica/Robusta/...)
	var coffeeNames = Enum.GetValues<CoffeeName>().Where(name => name.ToString() != "Unknown").Select(name => name.ToString().ToLower());
	var coffeeTypes = Enum.GetValues<CoffeeType>().Where(type => type.ToString() != "Unknown").Select(type => type.ToString().ToLower());
}

<div class="container py-4">

	<div class="d-flex align-items-center justify-content-between mb-3 gap-2 flex-wrap">
		<div>
			<h2 class="fw-bold mb-0">Shop</h2>
			<div class="text-muted small">Kies je bonen, type en aantal KG. Voeg toe aan je winkelmand.</div>
		</div>

		<div class="d-flex gap-2">
			<a class="btn btn-outline-secondary" href="/">Terug</a>

			<!-- Winkelmand knop -->
			<button class="btn btn-dark position-relative" type="button"
					  data-bs-toggle="offcanvas" data-bs-target="#cartCanvas" aria-controls="cartCanvas">
				🛒 Winkelmand
				<span id="cartBadge"
						class="position-absolute top-0 start-100 translate-middle badge rounded-pill bg-danger"
						style="display:none;">
					0
				</span>
			</button>
		</div>
	</div>

	@if (TempData["OrderPlaced"] is string msg) {
		<div class="alert alert-success alert-dismissible fade show shadow-sm" role="alert">
			@msg
			<button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
		</div>
	}

	@if (!ViewData.ModelState.IsValid) {
		<div class="alert alert-danger shadow-sm">
			<strong>Controleer je invoer:</strong>
			<div asp-validation-summary="All"></div>
		</div>
	}

	<form id="orderForm" asp-action="Create" method="post" class="card shadow-sm border-0 rounded-4">
		@Html.AntiForgeryToken()

		<div class="card-body p-4">
			<!-- Hidden inputs die model binding doen -->
			<input type="hidden" asp-for="CoffeeUserId" />
			<input type="hidden" asp-for="OrderId" />
			<input type="hidden" asp-for="Items" />
			@* <input type="hidden" asp-for="QuantityDictionary" /> *@

			<div class="d-flex align-items-center justify-content-between mb-3 flex-wrap gap-2">
				<h5 class="fw-semibold mb-0">Producten (per unit)</h5>
				<div class="text-muted small">
					Subtotaal winkelmand: <span class="fw-semibold">€<span id="cartTotal">0.00</span></span>
				</div>
			</div>

			<!-- Product grid: 1 kolom mobiel, 2 op md, 3 op lg -->
			<div class="row g-3">
				@foreach (var name in coffeeNames) {
					<div class="col-12 col-md-6 col-lg-4">
						<div class="border rounded-4 p-3 h-100 d-flex flex-column">
							<div class="d-flex align-items-start justify-content-between item-row">
								<div class="fw-bold fs-5">@(char.ToUpper(name[0]) + name.Substring(1))</div>
							</div>
							@* <span class="badge bg-light text-dark border">per unit</span> *@

							<hr class="my-3" />

							@foreach (var type in coffeeTypes) {
								<input type="hidden" id='@(type)_@(name)' value="0" />

								@foreach (var (coffee, index) in coffees
									.Where(coffee => coffee.Name.ToString().ToLower() == name && coffee.Type.ToString().ToLower() == type)
									.Select((coffee, index) => (coffee, index))) {
									int quantity;

									@* <input type="hidden" asp-for="Items[index]" /> *@

									<!-- Type blocks -->
									<div class="vstack gap-2">
										<div class="d-flex align-items-center justify-content-between gap-2">
											<div>
												<div class="fw-semibold">@type</div>
												<div class="text-muted small">€@coffee.Price.ToString("0.00")/totaal</div>
											</div>

											<div class="d-flex align-items-center gap-2">
												<select class="form-select form-select-sm qty"
														  id=@($"sel_{type}_{name}")
														  data-coffeeId="@coffee.Id"
														  data-price="@coffee.Price"
														  style="width: 84px;"
														  onchange="changeUnitQuantity(0, '@(type)_@(name)', event)">

													@for (quantity = 0; quantity <= 26; quantity++) {
														<option value="@quantity">@quantity @(quantity > 1 ? "units" : "unit")</option>
													}
												</select>

												<button type="button"
														  class="btn btn-sm btn-success text-nowrap"
														  data-key="@(type)_@(name)"
														  data-price="@coffee.Price"
														  onclick="addToCart(event)">
													+ Toevoegen
												</button>
											</div>
										</div>
									</div>

									<div class="mt-3 text-muted small">
										In winkelmand:
										<span class="fw-semibold" name=@($"inCart_{type}_{name}")>@quantity</span> @(quantity != 1 ? "units" : "unit") totaal
									</div>

									<div class="mt-auto pt-2"></div>
								}
							}
						</div>
					</div>
				}
			</div>

			<hr class="my-4" />
		</div>

		<button type="submit" class="btn btn-success btn-lg w-100 py-3 fw-semibold mt-4">
			Bestelling plaatsen
		</button>

		<!-- Offcanvas winkelmand -->
		<div class="offcanvas offcanvas-end" tabindex="-1" id="cartCanvas" aria-labelledby="cartCanvasLabel">
			<div class="offcanvas-header">
				<h5 class="offcanvas-title fw-bold" id="cartCanvasLabel">🛒 Winkelmand</h5>
				<button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
			</div>
			<div class="offcanvas-body">
				<div id="cartEmpty" class="text-muted">
					Je winkelmand is leeg. Voeg producten toe.
				</div>

				<div id="cartList" class="vstack gap-2"></div>

				<hr class="my-3" />

				<div class="d-flex justify-content-between">
					<div class="fw-semibold">Totaal</div>
					<div class="fw-bold">€<span id="cartTotal2">0.00</span></div>
				</div>

				<div class="small text-muted mt-2">
					*De winkelmand vult automatisch de hidden inputs voor je order.
				</div>
			</div>
		</div>
	</form>

	<hr class="my-4" />
</div>

@section Scripts {
	@{
		await Html.RenderPartialAsync("_ValidationScriptsPartial");
	}

	<script>
		// Cart storage: key = `${type}_${name}` -> { type, name, quantityInput, price, element, selector }
		const cart = new Map();

		// C# -> JSON array
		const coffeeNames = @Html.Raw(JsonSerializer.Serialize(
			coffeeNames.Select(name => name.ToLower()).ToArray()
		));
		const coffeeTypes = @Html.Raw(JsonSerializer.Serialize(
		 	coffeeTypes.Select(type => type.ToLower()).ToArray()
		));

		const list  = document.getElementById("cartList");
		const empty = document.getElementById("cartEmpty");
		const table = document.getElementById("orderItemsTable");
		let itemCounter = 0; // Global partial index

		list.innerHTML = "";

		// Initialize cart entries and existing rows
		for (const name of coffeeNames) {
			for (const type of coffeeTypes) {
				const key = `${type}_${name}`;
				const selector = document.getElementById(`sel_${key}`);
				if (!selector) continue;

				const price = parseFloat(selector.dataset.price);
				const quantityInput = document.querySelector(`input[type="hidden"][id="${key}"]`);

				// Create base item in cart map
				const item = {
					type,
					name,
					quantityInput, // the hidden input element
					price,
					element: null, // will be filled when partial is loaded
					selector
				};
				cart.set(key, item);

				// If there are units already, ensure an element exists in the list
				const currentQuantity = parseInt(quantityInput?.value || "0");
				if (currentQuantity > 0) {
					// If initial rows are already rendered server-side, you could locate them here.
					// For now we just rely on renderCart() to show the card once element exists.
				}
			}
		}

		function updateElement(item) {
			if (!item.element) return;

			const title = item.element.querySelector('[data-card-title]');
			const unitPrice = item.element.querySelector('[data-card-unit-price]');
			const totalQuantity = item.element.querySelector('[data-card-total-quantity]');
			const totalPrice = item.element.querySelector('[data-card-total-price]');

			const qty = parseInt(item.quantityInput?.value || "0");
			const lineTotal = qty * item.price;

			title.textContent = `${escapeHtml(item.type)} ${escapeHtml(item.name)}`;
			unitPrice.textContent = `${qty} • €${item.price.toFixed(2)}/unit`;
			totalQuantity.textContent = `${qty} unit${qty === 1 ? "" : "s"}`;
			totalPrice.textContent = `€ ${lineTotal.toFixed(2)}`;
		}

		async function addToCart(event) {
			if (!event) return;

			if (event.type === "submit") {
				event.preventDefault();
				return;
			}

			const key = event.target.dataset.key;
			const item = cart.get(key);
			if (!item) return;

			// Ensure hidden quantity is at least the selector's current value
			item.quantityInput.value = item.selector.value || "0";

			// Only request a new partial if no element exists yet
			if (!item.element) {
				const index = itemCounter++;
				const orderItem = {
						OrderId: @Model.OrderId,
						CoffeeId: parseInt(item.selector.dataset.coffeeid),
						Quantity: parseInt(item.quantityInput.value || "0"),
						UnitPrice: parseFloat(item.price),
						CreatedAt: Date.now()
				};

				const response = await fetch(`/orders/addorderitem/?index=${index}`, {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
						'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
					},
					body: JSON.stringify(orderItem)
				});

				if (response.ok) {
					const htmlRow = await response.text();
					const container = document.createElement("div");
					container.id = `card_${key}`;
					container.className = "border rounded-4 p-3";
					container.innerHTML = htmlRow;

					item.element = container;
					cart.set(key, item);

					list.appendChild(item.element);
					updateElement(item);
				}
			} else {
				// Already have a card, just update it
				updateElement(item);
			}

			// Keep quantities and UI in sync
			changeUnitQuantity(0, key);
			renderCart();
		}

		function removeFromCart(event) {
			if (!event) return;

			const el = event.target.closest("[id^='card_']");
			if (!el) return;

			const key = el.id.replace("card_", "");
			if (list.contains(el)) list.removeChild(el);

			const item = cart.get(key);
			if (!item) return;

			item.quantityInput.value = "0";
			cart.set(key, item);

			const label = document.querySelector(`[name="inCart_${key}"]`);
			if (label) label.innerText = "0";

			renderCart();
		}

		function changeUnitQuantity(difference, key = null, event = null) {
			if (!key && event) {
				const card = event.target.closest("[id^='card_']");
				if (!card) return;
				key = card.id.replace("card_", "");
			}
			if (!key) return;

			const item = cart.get(key);
			if (!item) return;

			const baseValue = parseInt(item.selector.value || "0");
			const newValue = Math.max(0, baseValue + difference);

			item.selector.value = newValue.toString();
			if (item.quantityInput) item.quantityInput.value = newValue.toString();
			cart.set(key, item);

			const label = document.querySelector(`[name="inCart_${key}"]`);
			if (label) label.innerText = newValue.toString();

			if (newValue <= 0 && item.element) {
				// Remove card when quantity hits zero
				if (list.contains(item.element)) list.removeChild(item.element);
				renderCart();
				return;
			}

			// Ensure element is visible
			if (item.element && !document.getElementById(item.element.id)) {
				list.appendChild(item.element);
			}

			updateElement(item);
			renderCart();
		}

		function renderCart() {
			let totalQuantityAll = 0;
			let totalPrice = 0;

			for (const [key, item] of cart.entries()) {
				const selectorValue = parseInt(item.selector.value || "0");

				const label = document.querySelector(`[name="inCart_${key}"]`);
				if (label) label.innerText = selectorValue.toString();

				if (!item || selectorValue <= 0) {
					// Hide card if present
					if (item?.element && list.contains(item.element)) {
						list.removeChild(item.element);
					}
					continue;
				}

				totalQuantityAll += selectorValue;
				totalPrice += selectorValue * item.price;

				if (item.quantityInput) item.quantityInput.value = selectorValue.toString();
				updateElement(item);

				if (item.element && !document.getElementById(item.element.id)) {
					list.appendChild(item.element);
				}
			}

			empty.style.display = totalQuantityAll === 0 ? "block" : "none";

			const badge = document.getElementById("cartBadge");
			if (totalQuantityAll > 0) {
				badge.style.display = "inline-block";
				badge.innerText = totalQuantityAll.toString();
			} else {
				badge.style.display = "none";
				badge.innerText = "0";
			}

			document.getElementById("cartTotal").innerText  = totalPrice.toFixed(2);
			document.getElementById("cartTotal2").innerText = totalPrice.toFixed(2);
		}

		function escapeHtml(str) {
			return (str ?? "")
				.toString()
				.replaceAll("&", "&amp;")
				.replaceAll("<", "&lt;")
				.replaceAll(">", "&gt;")
				.replaceAll('"', "&quot;")
				.replaceAll("'", "&#39;");
		}

		// Basic required fields popup
		// Not sure if needed
		// document.getElementById("orderForm").addEventListener("submit", function (e) {
			//// minstens 1 item in mand (minstens 1 hidden > 0)
			// let hasAny = false;
			// for (let i = 0; i < @*@coffees.Count()*@; i++) {
			// 	const sum =
			// 		getHiddenUnitQuantity(i, "Roasted") +
			// 		getHiddenUnitQuantity(i, "Ground") +
			// 		getHiddenUnitQuantity(i, "Raw");
			// 	if (sum > 0) { hasAny = true; break; }
			// }

			//const requiredIds = [
				// ["FirstName", "Voornaam"],
				// ["LastName", "Achternaam"],
				// ["Email", "Email"],
				// ["Street", "Straat"],
				// ["Postbus", "Postbus"],
				// ["City", "Stad"],
				// ["Postcode", "Postcode"],
				// ["Country", "Land"],
			//];

			// const missing = [];
			// for (const [id, label] of requiredIds) {
			// 	const val = document.getElementById(id)?.value?.trim();
			// 	if (!val) missing.push(label);
			// }

			// if (!hasAny) missing.unshift("Minstens 1 product in winkelmand");

			//// Popup tonen
			// if (missing.length > 0) {
			// 	e.preventDefault();
			// 	  alert("Je bent dit vergeten in te vullen:\n- " + missing.join("\n- "));
			// }
		// });

		// init
		renderCart();
	</script>
}